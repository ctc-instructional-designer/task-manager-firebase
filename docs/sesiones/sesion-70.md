## üõ°Ô∏è Sesi√≥n 70: Validaci√≥n de entradas y manejo de errores

### üéØ Objetivos de la sesi√≥n
- Implementar validaci√≥n robusta de datos de entrada
- Crear sistema centralizado de manejo de errores
- Mejorar experiencia de usuario con mensajes claros
- Prevenir datos corruptos en Firestore
- Establecer reglas de validaci√≥n consistentes

### üìã Contenidos clave
‚úÖ **Validaci√≥n frontend** - Prevenir env√≠o de datos inv√°lidos
‚úÖ **Manejo de errores** - Sistema robusto y user-friendly
‚úÖ **Feedback visual** - Estados de loading/error/success

---

### üèóÔ∏è Implementaci√≥n paso a paso

#### Paso 1: Crear utilidad de validaci√≥n
> **Archivo:** `src/utils/validation.js`
> **Acci√≥n:** Sistema centralizado de validaci√≥n

```javascript
// üéØ REGLAS DE VALIDACI√ìN PARA TAREAS
export const VALIDATION_RULES = {
  TITLE: {
    MIN_LENGTH: 1,
    MAX_LENGTH: 100,
    REQUIRED: true
  },
  DESCRIPTION: {
    MIN_LENGTH: 0,
    MAX_LENGTH: 500,
    REQUIRED: false
  }
};

// üéØ MENSAJES DE ERROR ESTANDARIZADOS
export const ERROR_MESSAGES = {
  TITLE_REQUIRED: 'El t√≠tulo es obligatorio',
  TITLE_TOO_SHORT: 'El t√≠tulo debe tener al menos 1 car√°cter',
  TITLE_TOO_LONG: `El t√≠tulo no puede tener m√°s de ${VALIDATION_RULES.TITLE.MAX_LENGTH} caracteres`,
  TITLE_INVALID: 'El t√≠tulo contiene caracteres no v√°lidos',

  DESCRIPTION_TOO_LONG: `La descripci√≥n no puede tener m√°s de ${VALIDATION_RULES.DESCRIPTION.MAX_LENGTH} caracteres`,
  DESCRIPTION_INVALID: 'La descripci√≥n contiene caracteres no v√°lidos',

  GENERIC_REQUIRED: 'Este campo es obligatorio',
  GENERIC_INVALID: 'El valor ingresado no es v√°lido'
};

// üéØ FUNCIONES DE VALIDACI√ìN

/**
 * Valida el t√≠tulo de una tarea
 * @param {string} title - El t√≠tulo a validar
 * @returns {object} { isValid: boolean, error: string }
 */
export const validateTitle = (title) => {
  // ‚úÖ Verificar que existe y no est√° vac√≠o
  if (!title || typeof title !== 'string') {
    return { isValid: false, error: ERROR_MESSAGES.TITLE_REQUIRED };
  }

  // üßπ Limpiar espacios extra
  const cleanTitle = title.trim();

  // ‚úÖ Verificar longitud m√≠nima
  if (cleanTitle.length < VALIDATION_RULES.TITLE.MIN_LENGTH) {
    return { isValid: false, error: ERROR_MESSAGES.TITLE_TOO_SHORT };
  }

  // ‚úÖ Verificar longitud m√°xima
  if (cleanTitle.length > VALIDATION_RULES.TITLE.MAX_LENGTH) {
    return { isValid: false, error: ERROR_MESSAGES.TITLE_TOO_LONG };
  }

  // üö´ Verificar caracteres no permitidos (ejemplo: solo texto b√°sico)
  const invalidCharsRegex = /[<>{}[\]\\\/]/;
  if (invalidCharsRegex.test(cleanTitle)) {
    return { isValid: false, error: ERROR_MESSAGES.TITLE_INVALID };
  }

  return { isValid: true, error: null, cleanValue: cleanTitle };
};

/**
 * Valida la descripci√≥n de una tarea
 * @param {string} description - La descripci√≥n a validar
 * @returns {object} { isValid: boolean, error: string }
 */
export const validateDescription = (description) => {
  // ‚úÖ La descripci√≥n es opcional
  if (!description || description === '') {
    return { isValid: true, error: null, cleanValue: '' };
  }

  // ‚úÖ Verificar tipo
  if (typeof description !== 'string') {
    return { isValid: false, error: ERROR_MESSAGES.DESCRIPTION_INVALID };
  }

  // üßπ Limpiar espacios extra
  const cleanDescription = description.trim();

  // ‚úÖ Verificar longitud m√°xima
  if (cleanDescription.length > VALIDATION_RULES.DESCRIPTION.MAX_LENGTH) {
    return { isValid: false, error: ERROR_MESSAGES.DESCRIPTION_TOO_LONG };
  }

  // üö´ Verificar caracteres no permitidos
  const invalidCharsRegex = /[<>{}[\]\\]/;
  if (invalidCharsRegex.test(cleanDescription)) {
    return { isValid: false, error: ERROR_MESSAGES.DESCRIPTION_INVALID };
  }

  return { isValid: true, error: null, cleanValue: cleanDescription };
};

/**
 * Valida un objeto completo de tarea
 * @param {object} taskData - Los datos de la tarea
 * @returns {object} { isValid: boolean, errors: object, cleanData: object }
 */
export const validateTaskData = (taskData) => {
  const errors = {};
  let isValid = true;
  const cleanData = {};

  // ‚úÖ Validar t√≠tulo
  const titleValidation = validateTitle(taskData.title);
  if (!titleValidation.isValid) {
    errors.title = titleValidation.error;
    isValid = false;
  } else {
    cleanData.title = titleValidation.cleanValue;
  }

  // ‚úÖ Validar descripci√≥n
  const descriptionValidation = validateDescription(taskData.description);
  if (!descriptionValidation.isValid) {
    errors.description = descriptionValidation.error;
    isValid = false;
  } else {
    cleanData.description = descriptionValidation.cleanValue;
  }

  return { isValid, errors, cleanData };
};

/**
 * Sanitiza y normaliza datos de entrada
 * @param {object} data - Datos a sanitizar
 * @returns {object} Datos limpios
 */
export const sanitizeTaskData = (data) => {
  return {
    title: (data.title || '').toString().trim(),
    description: (data.description || '').toString().trim(),
    completed: Boolean(data.completed)
  };
};

// üéØ VALIDADORES ESPEC√çFICOS ADICIONALES

/**
 * Valida ID de tarea
 * @param {string} taskId - ID a validar
 * @returns {object} { isValid: boolean, error: string }
 */
export const validateTaskId = (taskId) => {
  if (!taskId || typeof taskId !== 'string') {
    return { isValid: false, error: 'ID de tarea inv√°lido' };
  }

  // ‚úÖ Verificar formato b√°sico de Firebase ID
  if (taskId.length < 10 || taskId.length > 25) {
    return { isValid: false, error: 'Formato de ID inv√°lido' };
  }

  return { isValid: true, error: null };
};

/**
 * Valida estado booleano
 * @param {any} completed - Estado a validar
 * @returns {object} { isValid: boolean, error: string, cleanValue: boolean }
 */
export const validateCompleted = (completed) => {
  // ‚úÖ Convertir a boolean de manera segura
  let cleanValue = false;

  if (typeof completed === 'boolean') {
    cleanValue = completed;
  } else if (typeof completed === 'string') {
    cleanValue = completed.toLowerCase() === 'true';
  } else if (typeof completed === 'number') {
    cleanValue = completed === 1;
  }

  return { isValid: true, error: null, cleanValue };
};
```

#### Paso 2: Crear sistema de notificaciones
> **Archivo:** `src/components/ui/Toast.jsx`
> **Acci√≥n:** Sistema de notificaciones para feedback

```jsx
import { useState, useEffect } from 'react';

// üéØ Componente Toast individual
const ToastItem = ({ toast, onRemove }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      onRemove(toast.id);
    }, toast.duration || 5000);

    return () => clearTimeout(timer);
  }, [toast.id, toast.duration, onRemove]);

  const getToastStyles = () => {
    const baseClasses = "mb-2 p-4 rounded shadow-lg max-w-sm transform transition-all";

    switch (toast.type) {
      case 'success':
        return `${baseClasses} bg-green-500 text-white`;
      case 'error':
        return `${baseClasses} bg-red-500 text-white`;
      case 'warning':
        return `${baseClasses} bg-yellow-500 text-white`;
      case 'info':
      default:
        return `${baseClasses} bg-blue-500 text-white`;
    }
  };

  const getIcon = () => {
    switch (toast.type) {
      case 'success': return '‚úÖ';
      case 'error': return '‚ùå';
      case 'warning': return '‚ö†Ô∏è';
      case 'info':
      default: return '‚ÑπÔ∏è';
    }
  };

  return (
    <div className={getToastStyles()}>
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <span className="mr-2">{getIcon()}</span>
          <div>
            {toast.title && (
              <div className="font-semibold">{toast.title}</div>
            )}
            <div className={toast.title ? 'text-sm' : ''}>{toast.message}</div>
          </div>
        </div>
        <button
          onClick={() => onRemove(toast.id)}
          className="ml-4 text-white hover:text-gray-200"
        >
          ‚úï
        </button>
      </div>
    </div>
  );
};

// üéØ Contenedor de Toasts
const ToastContainer = ({ toasts, onRemoveToast }) => {
  if (toasts.length === 0) return null;

  return (
    <div className="fixed top-4 right-4 z-50">
      {toasts.map(toast => (
        <ToastItem
          key={toast.id}
          toast={toast}
          onRemove={onRemoveToast}
        />
      ))}
    </div>
  );
};

// üéØ Hook para manejo de toasts
export const useToast = () => {
  const [toasts, setToasts] = useState([]);

  const addToast = (type, message, title = null, duration = 5000) => {
    const id = Date.now() + Math.random();
    const toast = { id, type, message, title, duration };

    setToasts(prev => [...prev, toast]);
    return id;
  };

  const removeToast = (id) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  };

  const clearToasts = () => {
    setToasts([]);
  };

  // üéØ M√©todos de conveniencia
  const success = (message, title = null) => addToast('success', message, title);
  const error = (message, title = null) => addToast('error', message, title);
  const warning = (message, title = null) => addToast('warning', message, title);
  const info = (message, title = null) => addToast('info', message, title);

  return {
    toasts,
    addToast,
    removeToast,
    clearToasts,
    success,
    error,
    warning,
    info,
    ToastContainer: () => <ToastContainer toasts={toasts} onRemoveToast={removeToast} />
  };
};

export default ToastContainer;
```

#### Paso 3: Mejorar TaskForm con validaci√≥n
> **Archivo:** `src/components/TaskForm.jsx`
> **Acci√≥n:** Validaci√≥n en tiempo real y feedback

```jsx
import { useState } from 'react';
import { createTask } from '../services/taskService';
import { validateTaskData, sanitizeTaskData } from '../utils/validation';
import { useToast } from './ui/Toast';

const TaskForm = ({ onTaskCreated }) => {
  // üéØ Estados del formulario
  const [formData, setFormData] = useState({
    title: '',
    description: ''
  });

  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  // üéØ Sistema de notificaciones
  const toast = useToast();

  // üéØ Validaci√≥n en tiempo real
  const validateField = (name, value) => {
    const tempData = { ...formData, [name]: value };
    const validation = validateTaskData(tempData);

    setErrors(prev => ({
      ...prev,
      [name]: validation.errors[name] || null
    }));

    return !validation.errors[name];
  };

  // üéØ Manejar cambios en inputs
  const handleInputChange = (e) => {
    const { name, value } = e.target;

    setFormData(prev => ({
      ...prev,
      [name]: value
    }));

    // ‚úÖ Validar solo si el campo ya fue tocado
    if (touched[name]) {
      validateField(name, value);
    }
  };

  // üéØ Manejar blur (cuando el usuario sale del campo)
  const handleInputBlur = (e) => {
    const { name, value } = e.target;

    setTouched(prev => ({
      ...prev,
      [name]: true
    }));

    validateField(name, value);
  };

  // üéØ Env√≠o del formulario con validaci√≥n completa
  const handleSubmit = async (e) => {
    e.preventDefault();

    // üßπ Sanitizar datos antes de validar
    const sanitizedData = sanitizeTaskData(formData);

    // ‚úÖ Validaci√≥n completa
    const validation = validateTaskData(sanitizedData);

    if (!validation.isValid) {
      setErrors(validation.errors);
      setTouched({ title: true, description: true });

      // üì¢ Mostrar error general
      toast.error('Por favor corrige los errores en el formulario', 'Formulario inv√°lido');
      return;
    }

    // üöÄ Enviar datos limpios
    setLoading(true);
    try {
      const result = await createTask(validation.cleanData);

      if (result.success) {
        // üéâ √âxito
        toast.success(`Tarea "${validation.cleanData.title}" creada exitosamente`);

        // üßπ Limpiar formulario
        setFormData({ title: '', description: '' });
        setErrors({});
        setTouched({});

        // üîÑ Notificar al padre
        onTaskCreated?.();
      } else {
        // ‚ùå Error del servidor
        toast.error(result.error, 'Error al crear tarea');
      }
    } catch (error) {
      console.error('Error inesperado:', error);
      toast.error('Ocurri√≥ un error inesperado', 'Error');
    } finally {
      setLoading(false);
    }
  };

  // üéØ Obtener estado visual del campo
  const getFieldClasses = (fieldName) => {
    const baseClasses = "w-full p-3 border rounded transition-colors";

    if (errors[fieldName] && touched[fieldName]) {
      return `${baseClasses} border-red-500 bg-red-50 focus:border-red-500 focus:outline-none`;
    }

    if (touched[fieldName] && !errors[fieldName] && formData[fieldName]) {
      return `${baseClasses} border-green-500 bg-green-50 focus:border-green-500 focus:outline-none`;
    }

    return `${baseClasses} border-gray-300 focus:border-blue-500 focus:outline-none`;
  };

  return (
    <>
      <div className="bg-white p-6 rounded-lg shadow-sm border">
        <h2 className="text-2xl font-bold mb-6 text-gray-800">‚úçÔ∏è Nueva Tarea</h2>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Campo T√≠tulo */}
          <div>
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-2">
              üìù T√≠tulo *
            </label>
            <input
              type="text"
              id="title"
              name="title"
              value={formData.title}
              onChange={handleInputChange}
              onBlur={handleInputBlur}
              className={getFieldClasses('title')}
              placeholder="¬øQu√© necesitas hacer?"
              disabled={loading}
              maxLength={100}
            />

            {/* Contador de caracteres */}
            <div className="flex justify-between mt-1">
              <div>
                {errors.title && touched.title && (
                  <span className="text-red-500 text-sm">‚ùå {errors.title}</span>
                )}
              </div>
              <span className="text-gray-400 text-sm">
                {formData.title.length}/100
              </span>
            </div>
          </div>

          {/* Campo Descripci√≥n */}
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-2">
              üìÑ Descripci√≥n (opcional)
            </label>
            <textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              onBlur={handleInputBlur}
              className={`${getFieldClasses('description')} h-20 resize-none`}
              placeholder="Detalles adicionales..."
              disabled={loading}
              maxLength={500}
            />

            {/* Contador de caracteres */}
            <div className="flex justify-between mt-1">
              <div>
                {errors.description && touched.description && (
                  <span className="text-red-500 text-sm">‚ùå {errors.description}</span>
                )}
              </div>
              <span className="text-gray-400 text-sm">
                {formData.description.length}/500
              </span>
            </div>
          </div>

          {/* Bot√≥n de env√≠o */}
          <button
            type="submit"
            disabled={loading || Object.keys(errors).some(key => errors[key])}
            className={`w-full py-3 px-4 rounded font-medium transition-colors ${
              loading || Object.keys(errors).some(key => errors[key])
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-500 hover:bg-blue-600 text-white'
            }`}
          >
            {loading ? (
              <>
                <span className="inline-block animate-spin mr-2">‚è≥</span>
                Creando tarea...
              </>
            ) : (
              '‚úÖ Crear tarea'
            )}
          </button>
        </form>

        {/* Indicadores de validaci√≥n */}
        <div className="mt-4 text-sm text-gray-600">
          <div className="flex items-center gap-4">
            <span className={formData.title && !errors.title ? 'text-green-600' : 'text-gray-400'}>
              ‚úÖ T√≠tulo v√°lido
            </span>
            <span className={formData.description && !errors.description ? 'text-green-600' : 'text-gray-400'}>
              üìÑ Descripci√≥n opcional
            </span>
          </div>
        </div>
      </div>

      {/* Contenedor de notificaciones */}
      <toast.ToastContainer />
    </>
  );
};

export default TaskForm;
```

#### Paso 4: Mejorar servicios con validaci√≥n
> **Archivo:** `src/services/taskService.js`
> **Acci√≥n:** Validaci√≥n a nivel de servicio

```javascript
import {
  collection,
  addDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  doc,
  serverTimestamp
} from 'firebase/firestore';
import { db } from './firebase';
import { validateTaskData, validateTaskId, sanitizeTaskData } from '../utils/validation';

const COLLECTION_NAME = 'tasks';

// üéØ MANEJO CENTRALIZADO DE ERRORES FIREBASE
const handleFirebaseError = (error) => {
  console.error('Firebase Error:', error);

  // üîç Mapear c√≥digos de error espec√≠ficos
  const errorMappings = {
    'permission-denied': 'No tienes permisos para realizar esta acci√≥n',
    'unavailable': 'Servicio no disponible, intenta m√°s tarde',
    'not-found': 'El recurso solicitado no existe',
    'already-exists': 'El recurso ya existe',
    'resource-exhausted': 'Se ha excedido la cuota de uso',
    'unauthenticated': 'Debes iniciar sesi√≥n para continuar',
    'deadline-exceeded': 'La operaci√≥n tard√≥ demasiado tiempo',
    'invalid-argument': 'Los datos proporcionados no son v√°lidos'
  };

  return errorMappings[error.code] || error.message || 'Error desconocido';
};

// ‚úÖ Crear tarea con validaci√≥n completa
export const createTask = async (taskData) => {
  try {
    console.log('üöÄ Creando tarea con validaci√≥n...', taskData);

    // üßπ Sanitizar datos de entrada
    const sanitizedData = sanitizeTaskData(taskData);

    // ‚úÖ Validar datos sanitizados
    const validation = validateTaskData(sanitizedData);
    if (!validation.isValid) {
      console.warn('‚ùå Datos inv√°lidos:', validation.errors);
      return {
        success: false,
        error: 'Datos inv√°lidos: ' + Object.values(validation.errors).join(', '),
        validationErrors: validation.errors
      };
    }

    // üì¶ Preparar documento con metadata
    const taskDocument = {
      ...validation.cleanData,
      completed: false,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    // üî• Guardar en Firestore
    const docRef = await addDoc(collection(db, COLLECTION_NAME), taskDocument);

    console.log('‚úÖ Tarea creada exitosamente:', docRef.id);
    return {
      success: true,
      data: {
        id: docRef.id,
        ...validation.cleanData,
        completed: false,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    };

  } catch (error) {
    const friendlyError = handleFirebaseError(error);
    console.error('‚ùå Error al crear tarea:', friendlyError);
    return { success: false, error: friendlyError };
  }
};

// ‚úÖ Actualizar tarea con validaci√≥n
export const updateTask = async (taskId, updates) => {
  try {
    console.log('üìù Actualizando tarea con validaci√≥n...', { taskId, updates });

    // ‚úÖ Validar ID de tarea
    const idValidation = validateTaskId(taskId);
    if (!idValidation.isValid) {
      return { success: false, error: idValidation.error };
    }

    // üßπ Sanitizar actualizaciones
    const sanitizedUpdates = sanitizeTaskData(updates);

    // ‚úÖ Validar datos (solo campos que se est√°n actualizando)
    const validation = validateTaskData({
      title: sanitizedUpdates.title || 'T√≠tulo temporal', // Para validaci√≥n
      description: sanitizedUpdates.description || '',
      completed: sanitizedUpdates.completed
    });

    if (!validation.isValid) {
      return {
        success: false,
        error: 'Datos inv√°lidos: ' + Object.values(validation.errors).join(', '),
        validationErrors: validation.errors
      };
    }

    // üì¶ Preparar actualizaciones limpias
    const cleanUpdates = {
      ...sanitizedUpdates,
      updatedAt: serverTimestamp()
    };

    // üî• Actualizar en Firestore
    const taskRef = doc(db, COLLECTION_NAME, taskId);
    await updateDoc(taskRef, cleanUpdates);

    console.log('‚úÖ Tarea actualizada exitosamente');
    return {
      success: true,
      data: { id: taskId, ...cleanUpdates, updatedAt: new Date() }
    };

  } catch (error) {
    const friendlyError = handleFirebaseError(error);
    console.error('‚ùå Error al actualizar tarea:', friendlyError);
    return { success: false, error: friendlyError };
  }
};

// ‚úÖ Eliminar tarea con validaci√≥n
export const deleteTask = async (taskId) => {
  try {
    console.log('üóëÔ∏è Eliminando tarea con validaci√≥n...', taskId);

    // ‚úÖ Validar ID de tarea
    const idValidation = validateTaskId(taskId);
    if (!idValidation.isValid) {
      return { success: false, error: idValidation.error };
    }

    // üî• Eliminar de Firestore
    const taskRef = doc(db, COLLECTION_NAME, taskId);
    await deleteDoc(taskRef);

    console.log('‚úÖ Tarea eliminada exitosamente');
    return { success: true, deletedId: taskId };

  } catch (error) {
    const friendlyError = handleFirebaseError(error);
    console.error('‚ùå Error al eliminar tarea:', friendlyError);
    return { success: false, error: friendlyError };
  }
};

// ‚úÖ Obtener tareas (sin cambios, ya es robusto)
export const getTasks = async () => {
  try {
    console.log('üìñ Obteniendo tareas...');

    const querySnapshot = await getDocs(collection(db, COLLECTION_NAME));
    const tasks = [];

    querySnapshot.forEach((doc) => {
      const data = doc.data();
      tasks.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || new Date(),
        updatedAt: data.updatedAt?.toDate?.() || new Date()
      });
    });

    console.log(`‚úÖ ${tasks.length} tareas obtenidas`);
    return { success: true, data: tasks };

  } catch (error) {
    const friendlyError = handleFirebaseError(error);
    console.error('‚ùå Error al obtener tareas:', friendlyError);
    return { success: false, error: friendlyError, data: [] };
  }
};

// üéØ Funciones de utilidad con validaci√≥n
export const toggleTaskComplete = async (taskId, currentStatus) => {
  return await updateTask(taskId, { completed: !currentStatus });
};

export const updateTaskText = async (taskId, title, description) => {
  return await updateTask(taskId, { title, description });
};
```

---

### ‚úÖ Resultado de la sesi√≥n

Al completar esta sesi√≥n tendr√°s:

**üõ°Ô∏è Validaci√≥n robusta**
- ‚úÖ Sistema centralizado de validaci√≥n
- ‚úÖ Sanitizaci√≥n autom√°tica de datos
- ‚úÖ Validaci√≥n en tiempo real
- ‚úÖ Mensajes de error claros y espec√≠ficos

**üéØ Experiencia de usuario mejorada**
- ‚úÖ Feedback visual inmediato
- ‚úÖ Sistema de notificaciones (Toast)
- ‚úÖ Contadores de caracteres
- ‚úÖ Estados de loading/error/success

**üîí Seguridad de datos**
- ‚úÖ Prevenci√≥n de datos corruptos
- ‚úÖ Manejo centralizado de errores Firebase
- ‚úÖ Validaci√≥n tanto frontend como en servicios

### üß™ Pruebas cr√≠ticas

1. **Formulario vac√≠o** ‚Üí Debe mostrar error de t√≠tulo requerido
2. **T√≠tulo muy largo** ‚Üí Debe limitarse a 100 caracteres
3. **Caracteres especiales** ‚Üí Debe rechazar <>{}[]\
4. **Conexi√≥n fallida** ‚Üí Debe mostrar error user-friendly
5. **Validaci√≥n en tiempo real** ‚Üí Errores aparecen al salir del campo

### üì∏ Capturas de verificaci√≥n
1. **Campos con validaci√≥n** ‚Üí Bordes rojos/verdes
2. **Contadores de caracteres** funcionando
3. **Toasts de notificaci√≥n** apareciendo
4. **Formulario bloqueado** con datos inv√°lidos
5. **Console logs** mostrando validaciones

### üîÑ Pr√≥xima sesi√≥n
**Sesi√≥n 71:** Reglas de seguridad de Firestore - Protegeremos los datos a nivel de base de datos

---

**üéØ Conceptos clave aprendidos:**
- Validaci√≥n de entrada robusta
- Sanitizaci√≥n de datos de usuario
- Sistema de notificaciones Toast
- Manejo centralizado de errores Firebase
- Validaci√≥n en tiempo real vs batch
- Estados visuales de formularios
- Prevenci√≥n de datos corruptos
